"""
Модуль для обработки запросов и извлечения информации о товарах.

Описание:
1. Функция `filter_article_extract` используется для извлечения статьи или ключевой фразы из запроса.
2. Функция `filter_product_name` извлекает наименование товара из запроса, игнорируя стоп-слова и обрабатывая кавычки.
3. В модуле также загружается список стоп-слов, который комбинирует стандартные русские стоп-слова из NLTK и кастомный список.
"""

# Импорт необходимых библиотек для обработки текста
import re
from nltk.corpus import stopwords


# Функция для извлечения ключевого слова из запроса
def filter_article_extract(query: str) -> str:
    """
    Извлекает первую ключевую фразу (или артикул) из строки запроса.

    Аргументы:
    - query (str): Строка запроса пользователя.

    Возвращает:
    - str: Извлеченная фраза или пустая строка, если фраза не найдена.
    """
    # Используем регулярное выражение для поиска ключевой фразы (слова с дефисами)
    pattern = r'\b([\wА-Яа-яЁё]+(?:-[\wА-Яа-яЁё]+)+)\b'
    match = re.search(pattern, query, re.IGNORECASE)
    if match:
        return match.group(1)
    return ""


# Загружаем список стоп-слов из NLTK, если это еще не сделано
# nltk.download('stopwords')

# Стандартный русский список стоп-слов из библиотеки NLTK
russian_stopwords = set(stopwords.words('russian'))

# Кастомизированный список стоп-слов для обработки запросов
custom_stopwords = {
    "какая", "какой", "какие", "каков", "какова", "каковы",  # Вопросительные слова
    "где", "когда", "кто", "чей", "чье", "чья", "чьи",
    "что", "чем", "кому", "чего", "о", "из", "на", "в", "к", "про", "по", "об", "от", "со", "с", "без", "при", "под",
    "над", "для", "до", "между", "через", "среди", "у",  # Предлоги
    "мне", "тебе", "ему", "ей", "нам", "вам", "им",  # Местоимения
    "этот", "эта", "это", "эти", "тот", "та", "то", "те",  # Указательные
    "мой", "моя", "моё", "мои", "твой", "твоя", "твоё", "твои", "его", "её", "их", "наш", "наша", "наше", "наши", "ваш",
    "ваша", "ваше", "ваши",  # Притяжательные
    "цена", "стоимость", "сколько", "дешево", "дорого", "акция", "скидка", "бесплатно",  # Цены
    "товар", "товара", "предмет", "продукт", "позиция", "изделие", "экземпляр", "ассортимент",  # Общие слова про товар
    "купить", "продать", "заказать", "найти", "посмотреть", "показать", "подобрать", "узнать", "можешь", "можно",
    "доступно", "помочь", "подскажи", "имеется", "есть", "предложение", "стоит",  # Глаголы и действия
    "наличие", "в наличии", "закончился", "в продаже", "поставка", "доставка", "привезти", "ожидается", "появится",# Доступность
    "новый", "новинка", "старый", "б/у", "подержанный", "оригинал", "реплика",  # Описание состояния
    "размер", "цвет", "материал", "характеристики", "описание", "тип", "вид", "категория",  # Атрибуты товара
    "отзывы", "рейтинг", "лучший", "хороший", "плохой", "рекомендуемый", "популярный",  # Оценки и мнения
    "счет", "на счет", "по поводу", "что скажешь", "как насчет", "чем отличается", "разница", "отличия", "альтернатива",# Слова в формулировке запроса
    "из", "чего", "состоит", "включает", "содержит", "детали", "комплектация",  # Описание состава
}

# Объединяем стандартные и кастомные стоп-слова
stop_words = russian_stopwords | custom_stopwords


def filter_product_name(query: str) -> str:
    """
    Извлекает наименование товара из запроса, игнорируя стоп-слова.

    Аргументы:
    - query (str): Строка запроса пользователя, содержащая название товара в кавычках.

    Возвращает:
    - str: Извлеченное наименование товара в формате строки.
    """
    # Ищем фразу в кавычках («» или "")
    quote_match = re.search(r'[«"]([^«»"]+)[»"]', query)
    if not quote_match:
        return ""  # Если нет текста в кавычках, возвращаем пустую строку
    quoted_text = quote_match.group(1).strip()  # Извлекаем текст в кавычках
    quote_start = quote_match.start()  # Начало текста в кавычках

    # Текст перед открывающей кавычкой
    before_quote = query[:quote_start].strip()
    words = re.findall(r'\S+', before_quote)  # Разбиваем текст на слова

    # Собираем слова, игнорируя стоп-слова
    collected = []
    for word in reversed(words):
        normalized = re.sub(r'[^\wА-Яа-яЁё]', '', word).lower()  # Нормализуем слово
        if normalized in stop_words:  # Если слово в стоп-слове, прерываем сбор
            break
        collected.append(word)
    collected.reverse()

    # Формируем финальный результат с префиксом перед наименованием товара
    prefix = " ".join(collected).strip()
    return f"{prefix} «{quoted_text}»" if prefix else f"«{quoted_text}»"
